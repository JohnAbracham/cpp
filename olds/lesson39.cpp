/*
Указатель на указатель + динамическое выделение памяти (часть 1)
*/

#include <iostream>;
#include <string.h>;
 
using namespace std;
 
char **AddPtr (char **pp, int size, char *str); //прототип функции
 
int main()
{
    setlocale(LC_ALL, "rus");  
 
    int size = 0;//количество указателей на строки
    char **pp = 0;//указатель на массив указателей, которые содержат адреса строк
 
    cout << "~~~~~Добавляем указатели на пять строк и заполняем строки данными~~~~~" << endl;
    //вызов функции и присваивание возвращаемого значения
    pp = AddPtr(pp, size, "11111111111111111");
    size++; //=1  увеличиваем размер массива указателей
 
    pp = AddPtr(pp, size, "22222222222222222");
    size++;  //2
 
    pp = AddPtr(pp, size, "33333333333333333");
    size++;  //3
 
    pp = AddPtr(pp, size, "44444444444444444");
    size++;  //4
 
    pp = AddPtr(pp, size, "55555555555555555");
    size++;  //5
 
    for(int i = 0; i < size; i++)    //показываем все строки на экран
        cout << pp[i] << endl;  //достаточно обратиться к pp[i] - это адрес строки (0-й элемент)
    cout << endl;
 
      for(int i = 0; i < size; i++) //освобождаем память
    {
        delete [] pp[i]; // сначала выделенную под строки      
    }
    delete [] pp; // потом выделенную под массив указателей
    return 0;
}
 
char **AddPtr (char **pp, int size, char *str)
{
    if(size == 0){
        pp = new char *[size+1]; //выделяем память для указателя на строку
    }
    else{   //если массив уже не пустой, данные надо скопировать во временный массив **copy
        char **copy = new char* [size+1]; //создаем временный массив
        for(int i = 0; i < size; i++) //копируем в него адреса уже определенных строк
        {
            copy[i] = pp[i];
        }  
        //теперь строки хранятся в адресах copy
 
        delete [] pp; //освобождаем память, которая указывала на строки
 
        pp = copy; //показываем указателю на какие адреса теперь ссылаться
    }
 
    pp[size] = new char [strlen(str) + 1];  //выделяем память на новую строку
    strcpy(pp[size], str);  //и копируем новую строку в элемент pp[size].
 
    return pp;
}
